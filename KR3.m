%6.1--------------------------------------------------------------------------------------------------------
% 1) Izmantojot hordu metodi, atrast vienādojuma
% 0.1x^5 + x^4 - 3x = arctg3x - 2cosX
% tuvinato sakni péc 4 iterācijām, ja sakuma tuvinājums [1 2].
% Atbildi dod ar četriem cipariem aiz komata.

%%uzdevums1
clc; clear; format compact

f = @(x) 0.1*x.^5 + x.^4 - 3*x - atan(3*x) + 2*cos(x);
% сюда вписывается УРАВНЕНИЕ из условия
% всё должно быть перенесено в левую часть и приравнено к 0
% если в условии другие коэффициенты или функции — меняются ТОЛЬКО цифры и функции здесь

a = 1;
b = 2;
% a и b — это начальный интервал [1; 2]
% если в условии будет, например, [2; 5], то пишем a=2, b=5

for k = 1:4
% 4 — это количество итераций из условия
% если в задании написано «сделать 6 итераций» — меняем 4 на 6

    x = b - f(b)*(b-a)/(f(b)-f(a));
    % эту строку НЕ ТРОГАЕМ — она одинаковая во всех заданиях такого типа

    a = b;
    b = x;
    % эти строки тоже никогда не меняются
end

fprintf("%.4f\n",x);
% 4 знака после запятой — потому что так написано в задании
% если нужно 3 знака — пишем "%.3f"


% 2) Atrisināt vienādojumu 0.2x^3 – 5x + 5 = e^(0,3x) ar Ņūtona metodi.
% Atrast vislielāko vienādojuma sakni (precizitāte 10^(-4)).
% Atbildi dod ar četriem cipariem aiz komata.

%%uzdevums2
clc; clear; format compact

f = @(x) 0.2*x.^3 - 5*x + 5 - exp(0.3*x);
% сюда переписывается уравнение из условия
% правая часть уравнения ОБЯЗАТЕЛЬНО переносится влево
% если степени, коэффициенты или exp другие — меняются только они

df = @(x) 0.6*x.^2 - 5 + 0.3*exp(0.3*x);
% здесь производная предыдущей строки
% если в условии другое уравнение — эта строка ВСЕГДА меняется

x = 5;
% начальное приближение
% если в задании сказано «наибольший корень» — берем большое положительное число
% если «наименьший» — отрицательное

eps = 1e-4;
% точность из условия
% 10^(-5) → eps = 1e-5

while true
    x_new = x - f(x)/df(x);
    % эту строку не меняем никогда

    if abs(x_new-x) < eps
        % сравнение с точностью из условия
        break;
    end

    x = x_new;
end

fprintf("%.4f\n",x_new);
% формат ответа по условию


%3) Atrisināt sistēmu
% 	общая скобка: sin(0.5*x2 - 3) + 2.9*x1 = -2
% 	общая скобка: 0.75*x2 + cos(2.2*x1 - 2.9) + 2 = 0
% ar Ņūtona metodi apgabalā −3 ≤ x1 ≤ 2,−5 ≤ x2 ≤ −1 (precizitāte 10^-7 ).
% Aprēķināt x2 .Atbildi dod ar četriem cipariem aiz komata.

%%uzdevums3
clc; clear; format compact

f1 = @(x1,x2) sin(0.5*x2 - 3) + 2.9*x1 + 2;
% первое уравнение из условия
% число справа (= -2) перенесено влево
% если в задании другие числа — меняются только они

f2 = @(x1,x2) 0.75*x2 + cos(2.2*x1 - 2.9) + 2;
% второе уравнение из условия
% если справа 0 — просто переписывается

J = @(x1,x2) [ 2.9, 0.5*cos(0.5*x2 - 3);
              -2.2*sin(2.2*x1 - 2.9), 0.75 ];
% сюда вписываются коэффициенты из системы
% если система другая — эта матрица тоже будет другой

x1 = 0;
x2 = -3;
% начальное приближение
% берётся из диапазона, который указан в условии

eps = 1e-7;
% точность из условия

while true
    F = [-f1(x1,x2); -f2(x1,x2)];
    % эту строку не меняем

    d = J(x1,x2)\F;
    % эту строку тоже не меняем

    x1_new = x1 + d(1);
    x2_new = x2 + d(2);

    if norm([x1_new-x1, x2_new-x2]) < eps
        break;
    end

    x1 = x1_new;
    x2 = x2_new;
end

fprintf("%.4f\n",x2_new);
% выводится именно x2, потому что так требует условие


%4) Izmantojot hordu metodi, atrast minimalo pozitivo skaitli a,
% kas apmierina vienadojumu ∫3 сверху,1 снизу e^(-0.3x)sqrt(4+ax^3)dx = 4
% (precizitate ε = 0.0001). Atbildi dod ar četriem cipariem aiz komata.

%%uzdevums4
clc; clear; format compact

I = @(a) integral(@(x) exp(-0.3*x).*sqrt(4 + a*x.^3), 1, 3);
% сюда вписывается интеграл из условия
% 1 и 3 — пределы интегрирования
% если в задании другие пределы или функция — меняются ТОЛЬКО они

F = @(a) I(a) - 4;
% 4 — это число, с которым должен быть равен интеграл
% если в условии другое число — меняем 4

a1 = 0.1;
a2 = 2;
% начальный интервал для параметра a
% всегда берётся положительный, если в условии сказано «a > 0»

eps = 1e-4;
% точность из условия

while abs(a2-a1) > eps
    a_new = a2 - F(a2)*(a2-a1)/(F(a2)-F(a1));
    % формулу не меняем

    a1 = a2;
    a2 = a_new;
end

fprintf("%.4f\n",a2);
% вывод результата



%5) Dota vienādojumu sistēma
%общая скобка:2x^5 + 3y^5 = -75
%общая скобка:(x^2)/5 + (y^2)/5 = 1
%Uzzīmēt funkciju f1(x) un f2(x) grafikus (vienā zīmēšanas logā),
%kas atbilst vienādojumu sistēmai
%общая скобка:f1(x) = 0
%общая скобка:f2(x) = 0

%%uzdevums5
clc; clear; close all; format compact

f1 = @(x,y) 2*x.^5 + 3*y.^5 + 75;
% первое уравнение системы
% число −75 перенесено влево

f2 = @(x,y) x.^2/5 + y.^2/5 - 1;
% второе уравнение системы
% число 1 перенесено влево

figure; hold on; grid on;
% создание одного окна для графиков

fimplicit(@(x,y) f1(x,y), [-3,3,-3,3]);
% диапазон рисования
% если нужно больше/меньше — меняются эти числа

fimplicit(@(x,y) f2(x,y), [-3,3,-3,3], 'r');
% второй график в том же окне


%6.2-----------------------------------------------------------------------------------------------------------

% 1) Atrisinat vienadojumu 0.2x^3 — 5x + 5 = e^0,3x ar Ņūtona metodi.
% Atrast vismazāko vienādojuma sakni (precizitāte 10^-4).
% Atbildi dod ar četriem cipariem aiz komata.

%%uzdevums1
clc; clear; format compact

f  = @(x) 0.2*x.^3 - 5*x + 5 - exp(0.3*x);
% сюда переписывается уравнение из условия
% 0.2x^3 − 5x + 5 = e^(0.3x)
% правая часть ОБЯЗАТЕЛЬНО переносится влево

df = @(x) 0.6*x.^2 - 5 + 0.3*exp(0.3*x);
% производная функции из строки выше
% если в задании другое уравнение — эта строка тоже меняется

x = -5;
% начальное приближение
% отрицательное число выбрано потому, что требуется НАИМЕНЬШИЙ корень

eps = 1e-4;
% точность из условия (10^(-4))

while true
    x_new = x - f(x)/df(x);
    % эту формулу не меняем ни в каких заданиях

    if abs(x_new-x) < eps
        % проверка точности по условию
        break;
    end

    x = x_new;
end

fprintf("%.4f\n",x_new);
% вывод результата с 4 знаками после запятой


% 2) Noteikt vienādojumu sistēmas
% общая скобка: 2x^5 + 3y^5 = -75
% общая скобка: (x^2)/5 + (y^2)/5 = 1
% reālo sakņu skaitu.

%%uzdevums2
clc; clear; format compact

f1 = @(x,y) 2*x.^5 + 3*y.^5 + 75;
% первое уравнение системы
% 2x^5 + 3y^5 = −75
% число −75 перенесено в левую часть

f2 = @(x,y) x.^2/5 + y.^2/5 - 1;
% второе уравнение системы
% (x^2)/5 + (y^2)/5 = 1
% число 1 перенесено влево

x_max = sqrt(5);
% максимальное значение x получено из второго уравнения:
% x^2/5 ≤ 1 → x ≤ sqrt(5)

x_bound = x_max*1.1;
% диапазон немного увеличен, чтобы не потерять решения

xv = linspace(-x_bound, x_bound, 400);
% набор значений x для перебора

count = 0;
% счётчик количества реальных решений

for i = 1:length(xv)
    x = xv(i);

    y1 = fzero(@(yy) f1(x,yy),0);
    % поиск y из первого уравнения при фиксированном x

    if abs(f2(x,y1)) < 1e-3
        % проверка, удовлетворяет ли найденное y второму уравнению
        count = count + 1;
    end
end

fprintf("%d\n",count);
% вывод количества реальных решений системы


% 3)Izmantojot Ņūtona metodi, atrast vienādojumu sistēmas

% общая скобка: 3y^2 - 2x^2 = 16
% общая скобка: x^3 + y^3 - 4xy = 2
% tuvinātas saknes normu ||z^(2)||_2 pēc 2 iterācijām,
% ja z^(n) = (x^(n)) un sākuma tuvinājums ir x^(0) = 2, y^(0) = -2.
%            (y^(n)) 
% Atbildi dod ar četriem cipariem aiz komata.

%%uzdevums3
clc; clear; format compact

f1 = @(x,y) 3*y.^2 - 2*x.^2 - 16;
% первое уравнение системы
% 3y^2 − 2x^2 = 16
% число 16 перенесено влево

f2 = @(x,y) x.^3 + y.^3 - 4*x.*y - 2;
% второе уравнение
% x^3 + y^3 − 4xy = 2
% число 2 перенесено влево

J = @(x,y) [ -4*x, 6*y;
             3*x.^2 - 4*y, 3*y.^2 - 4*x ];
% матрица коэффициентов, полученная из системы
% если система меняется — эта матрица тоже меняется

x = 2;
y = -2;
% начальное приближение из условия: x(0)=2, y(0)=−2

for k = 1:2
% выполняем ровно 2 итерации, как указано в задании

    F = [-f1(x,y); -f2(x,y)];
    % вектор значений уравнений

    d = J(x,y)\F;
    % вычисление поправки

    x = x + d(1);
    y = y + d(2);
    % обновление значений x и y
end

n = norm([x y],2);
% вычисление нормы вектора (x,y) после 2 итераций

fprintf("%.4f\n",n);
% вывод нормы с 4 знаками после запятой


% 4) Noteikt vienādojuma sin 3x = (x+2)/4 - 3 reālo sakņu skaitu.

%%uzdevums4
clc; clear; format compact

f = @(x) sin(3*x) - (x+2)/4 + 3;
% уравнение из условия
% sin(3x) = (x+2)/4 − 3
% всё перенесено в левую часть

step1_1 = -1 + 3;
step1_2 = step1_1 * 4;
x_min = step1_2 - 2;
% вычисление левой границы интервала поиска корней
% все числа (3, 4, 2) взяты из уравнения

step2_1 = 1 + 3;
step2_2 = step2_1 * 4;
x_max = step2_2 - 2;
% вычисление правой границы интервала

x = linspace(x_min, x_max, 20000);
% создание большого количества точек на интервале

fx = f(x);
count = 0;
% счётчик количества корней

for k = 1:length(x)-1
    if fx(k)*fx(k+1) < 0
        % если функция меняет знак — между точками есть корень
        count = count + 1;
    end
end

fprintf('%d\n', count);
% вывод количества реальных корней


% 5) Dots vienadojums 2ln(x + 3) + x^2 = -3x + 5.
% Uzzimet funkcijas f(x) grafiku, kas atbilst vienadojumam f(x) = 0.

%%uzdevums5
clc; clear; close all; format compact

f = @(x) 2*log(x+3) + x.^2 + 3*x - 5;
% уравнение из условия
% 2ln(x+3) + x^2 = −3x + 5
% правая часть перенесена влево

fplot(f, [-2.9, 5], 'LineWidth', 1.6);
% построение графика функции f(x)=0
% левая граница чуть больше −3, так как ln(x+3) определён при x > −3

grid on;
% включение сетки для наглядности


7.1--------------------------------------------------------------------------------------------------------------
%+++++++++
% 1) Atrisinat Košī problēmu (1 + 3x)y' + 2xy + (1 + 3e^x)y'' = 4 + x^2，
% y(0.22) = 0.38 , y'(0.22) = 1.55, intervālā [ 0.22, 6.77].
% Uzzimét funkcijas y'(x) grafiku.

%%1uzdevums
clc; clearvars; close all;
format compact;
% служебные команды — НЕ ТРОГАЕМ

x0 = 0.22;
xf = 6.77;
% начало и конец интервала из условия
% МЕНЯЕМ ТОЛЬКО если в задании другой интервал

y0 = 0.38;
yp0 = 1.55;
% начальные условия y(x0) и y'(x0)
% МЕНЯЕМ ТОЛЬКО числа из условия

odefun = @(x,z) [z(2); ...
    (4+x.^2-(1+3*x).*z(2)-2*x.*z(1))./(1+3*exp(x))];
% z(1)=y, z(2)=y'
% здесь записано дифференциальное уравнение из условия
% ЭТУ СТРОКУ МЕНЯЕМ, если в условии другое уравнение
% ОСТАЛЬНОЙ КОД НИЖЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-8,'AbsTol',1e-8);
% настройки точности
% МЕНЯЕМ ТОЛЬКО если в условии указана другая точность

sol = ode45(odefun,[x0,xf],[y0;yp0],opts);
% вызов ode45 — НЕ ТРОГАЕМ НИКОГДА

xx = linspace(x0,xf,600);
% количество точек для графика
% можно менять 600, на результат не влияет

zz = deval(sol,xx);
% вычисление решения — НЕ ТРОГАЕМ

yprime = zz(2,:);
% выбираем y'(x), потому что так требует условие
% если нужно y — берем zz(1,:)

figure;
plot(xx,yprime,'LineWidth',1.2);
grid on;
% построение графика — НЕ ТРОГАЕМ


%+++++++++
% 2) Atrisināt Košī problēmu y' - x^2siny = -y^2x,
% y(0) = 1 intervālā [0, 2.5].
% Aprēķināt y(1.77) ar precizitāti 0.0001.
% Atbildi dod ar četriem cipariem aiz komata.


%%2uzdevums
clc; clearvars; close all;
format long;
% служебные команды — НЕ ТРОГАЕМ

x0 = 0;
xf = 2.5;
% интервал из условия
% МЕНЯЕМ ТОЛЬКО числа

x_query = 1.77;
% точка, в которой ищем y(x)
% МЕНЯЕМ по условию

y0 = 1;
% начальное условие y(x0)
% МЕНЯЕМ ТОЛЬКО число

odefun = @(x,y) x.^2.*sin(y) - x.*y.^2;
% правая часть дифференциального уравнения
% ЭТУ СТРОКУ МЕНЯЕМ, если другое уравнение
% ВСЁ НИЖЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-7,'AbsTol',1e-9);
% точность для получения 0.0001
% МЕНЯЕМ ТОЛЬКО если требуется другая точность

sol = ode45(odefun,[x0,xf],y0,opts);
% ode45 — НЕ ТРОГАЕМ

y_at = deval(sol,x_query);
% получение значения решения — НЕ ТРОГАЕМ

fprintf('y(%.2f) = %.4f',x_query,y_at);
% формат вывода по условию


%+++++++++
% 3)Atrisināt Košī problēmu
% dy1/dx = 1/2 * y1^2 + x * y2
% dy2/dx = -1/2 * y2^2 + y1 * y2
% y1(0.2) = 1.25, y2(0.2) = 1.33 intervālā (0.2, 0.9).
% Uzzīmēt funkcijas y2(x) grafiku.

%%3uzdevums
clc; clearvars; close all;
format compact;
% служебные строки — НЕ ТРОГАЕМ

x0 = 0.2;
xf = 0.9;
% интервал
% МЕНЯЕМ только числа

y1_0 = 1.25;
y2_0 = 1.33;
% начальные условия
% МЕНЯЕМ только по условию

odefun = @(x,y)[0.5*y(1).^2 + x.*y(2);-0.5*y(2).^2 + y(1).*y(2)];
% система уравнений
% ЭТУ ФУНКЦИЮ МЕНЯЕМ при другой системе
% ОСТАЛЬНОЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-8,'AbsTol',1e-8);
% точность — МЕНЯЕМ при необходимости

sol = ode45(odefun,[x0,xf],[y1_0;y2_0],opts);
% ode45 — НЕ ТРОГАЕМ

xx = linspace(x0,xf,400);
YY = deval(sol,xx);
% вычисление решения — НЕ ТРОГАЕМ

y2 = YY(2,:);
% выбираем y2, потому что так требует условие
% если нужно y1 — берем YY(1,:)

figure;
plot(xx, y2,'LineWidth',1.2);
grid on;

%-------------------------
%4) Atrisināt Košī problēmu
%((2sinx)/x + arctg(3 + x))y'' + sqrt(5 + 3x^3)y'+ y''' + ln(cosx + x^2)y = 5x^3 + 2,
%y(2.23) = 3.55, y'(2.23) = 4.38, y''(2.23) = 7.46 intervālā [2.23, 7.42].
%Aprēķināt y''(3.41) ar precizitāti ε = 0.0001.
%Atbildi dod ar četriem cipariem aiz komata.

%%4uzdevums
clc; clearvars; close all;
format long;
% служебные команды — НЕ ТРОГАЕМ

x0 = 2.23; 
xf = 7.42;
% интервал
% МЕНЯЕМ только числа

x_query = 3.41;
% точка, где ищем y''
% МЕНЯЕМ по условию

z1_0 = 3.55;   
z2_0 = 4.38;   
z3_0 = 7.46;   
% z1=y, z2=y', z3=y''
% начальные условия — МЕНЯЕМ по условию

odefun = @(x,z)[z(2);z(3);5*x.^3+2-((2*sin(x)./x)+atan(3+x)).*z(3)-sqrt(5+3*x.^3).*z(2)-log(cos(x)+x.^2).*z(1)];
% система первого порядка
% ЭТУ ЧАСТЬ МЕНЯЕМ при другом уравнении
% ВСЁ НИЖЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-7,'AbsTol',1e-9);
% точность — МЕНЯЕМ только при другом ε

sol = ode45(odefun,[x0,xf],[z1_0;z2_0;z3_0],opts);
% ode45 — НЕ ТРОГАЕМ

z_at = deval(sol,x_query);
ypp_at = z_at(3);
% извлекаем y'' — НЕ ТРОГАЕМ

fprintf('%.4f\n',ypp_at);
% формат вывода по условию


%-------------------------
% 5) Atrisināt Košī problēmu  

% x'(t) = 2x(t) - 3t * y(t)  
% y'(t) = 1/5 y(t) + 4x(t)  

% x(5.5) = 1, y(5.5) = 1 intervālā (5.5  8.3).  
% Atrast x(6.75). Atbildi dod ar četriem cipariem aiz komata.

%%5uzdevums
clc; clearvars; close all;
format long;
% служебные команды — НЕ ТРОГАЕМ

t0 = 5.5;
tf = 8.3;
% интервал по t
% МЕНЯЕМ только числа

t_query = 6.75;
% точка, где ищем x(t)
% МЕНЯЕМ по условию

x0 = 1;
y0 = 1;
% начальные условия
% МЕНЯЕМ только числа

odefun = @(t,u)[ ...
    2*u(1) - 3*t.*u(2); ...
    4*u(1) + (1/5)*u(2)];
% система уравнений
% ЭТУ СТРОКУ МЕНЯЕМ при другой системе
% ОСТАЛЬНОЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-8,'AbsTol',1e-9);
% точность — МЕНЯЕМ при необходимости

sol = ode45(odefun,[t0,tf],[x0;y0],opts);
% ode45 — НЕ ТРОГАЕМ

u_at = deval(sol,t_query);
x_at = u_at(1);
% выбираем x(t) — НЕ ТРОГАЕМ

fprintf('%.4f\n',x_at);
% формат вывода по условию


7.2--------------------------------------------------------------------------------------------------------------
%+++++++
% 1) Atrisināt Koši problēmu
% ((2sinx)/x + arctg(3 + x)) y'' + sqrt(5 + 3x^3)y' + y''' + ln(cos x + x^2)y = 5x^3 + 2,
% y(2.23) = 3.55, y'(2.23) = 4.38, y''(2.23) = 7.46 intervālā [2.23, 7.42].

% Uzzimēt funkcijas y'(x) grafiku.

%%1uzdevums
clc; clearvars; close all;
format compact;
% служебные команды — НИКОГДА НЕ ТРОГАЕМ

x0 = 2.23;
xf = 7.42;
% начало и конец интервала из условия
% МЕНЯЕМ ТОЛЬКО числа, если другой интервал

IC = [3.55;4.38;7.46];
% IC — вектор начальных условий
% IC(1)=y, IC(2)=y', IC(3)=y''
% МЕНЯЕМ ТОЛЬКО значения из условия

odefun = @(x,z) [z(2);z(3);5*x.^3 + 2-((2*sin(x)./x)+atan(3+x)).* z(3)-sqrt(5+3*x.^3).* z(2)-log(cos(x)+x.^2).* z(1)];
% система первого порядка, полученная из уравнения
% ЭТУ ФУНКЦИЮ МЕНЯЕМ, если уравнение другое
% ВЕСЬ ОСТАЛЬНОЙ КОД НИЖЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-8,'AbsTol',1e-9);
% точность решения
% МЕНЯЕМ ТОЛЬКО если требуется другая точность

sol = ode45(odefun,[x0,xf],IC,opts);
% ode45 — НЕ ТРОГАЕМ НИКОГДА

xx = linspace(x0,xf,600);
% сетка для построения графика
% число 600 можно менять — на ответ не влияет

zz = deval(sol,xx);
% вычисление решения — НЕ ТРОГАЕМ

yprime = zz(2,:);
% берём y'(x), так как по условию нужен его график
% если нужен y — используем zz(1,:)

figure;
plot(xx, yprime, 'LineWidth', 1.2);
grid on;
% построение графика — НЕ ТРОГАЕМ


%++++++
% 2) Atrisināt Košī problēmu (1 + sinx)y'' + (1 + x^2)y + 2y' = 8x^2,
% y(0.33) = 0.52, y'(0.33) = 2.33, intervalā [0.33, 4.55].

% Aprēķināt y'(1.99) ar precizitāti 0.0001.
% Atbildi dod ar četriem cipariem aiz komata.

%%2uzdevums
clc; clearvars; close all;
format long;
% служебные строки — НЕ ТРОГАЕМ

x0 = 0.33;
xf = 4.55;
% интервал решения
% МЕНЯЕМ ТОЛЬКО числа

xq = 1.99;
% точка, где нужно найти y'
% МЕНЯЕМ по условию

IC = [0.52;2.33];
% IC(1)=y, IC(2)=y'
% начальные условия — МЕНЯЕМ ТОЛЬКО числа

odefun = @(x,z) [z(2);(8*x.^2-(1+x.^2).*z(1)-2.*z(2))./(1+sin(x))];
% дифференциальное уравнение, приведённое к системе
% ЭТУ СТРОКУ МЕНЯЕМ при другом уравнении
% ВСЁ НИЖЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-7,'AbsTol',1e-9);
% точность, достаточная для 0.0001
% МЕНЯЕМ ТОЛЬКО при другом ε

sol = ode45(odefun,[x0,xf],IC,opts);
% ode45 — НЕ ТРОГАЕМ

zq = deval(sol,xq);
% значение решения в точке xq — НЕ ТРОГАЕМ

yprime_q = zq(2);
% извлекаем y'(xq)

fprintf('%.4f\n',yprime_q);
% вывод ответа с четырьмя знаками


%---------
% Atrisināt Košī problēmu  

% y'''+( 5/(2x) + ln(sinx + sqrt(x^3)))y''+ sqrt(1 + x^2)y' + ln(5 + x^3)y = sqrt(x + 4),  
% y(3.55) = -1.25, y'(3.55) = 2.05, y''(3.55) = 3.42 intervalā [3.55, 7.24].  

% Aprēķināt y(5.32) ar precizitāti ε = 0.0001.  
% Atbildi dod ar četriem cipariem aiz komata.

%%3uzdevums
clc; clearvars; close all;
format long;
% служебные команды — НЕ ТРОГАЕМ

x0 = 3.55;
xf = 7.24;
% интервал решения

xq = 5.32;
% точка, где нужно найти y(x)

IC = [-1.25;2.05;3.42];
% IC(1)=y, IC(2)=y', IC(3)=y''
% начальные условия — МЕНЯЕМ по условию

odefun = @(x,z) [z(2);z(3);sqrt(x + 4)-((5./(2.*x))+log(sin(x)+x.^(3/2))).* z(3)-sqrt(1+x.^2).*z(2)-log(5+x.^3).*z(1)];
% система первого порядка
% ЭТУ ФУНКЦИЮ МЕНЯЕМ при другом уравнении

opts = odeset('RelTol',1e-7,'AbsTol',1e-9);
% точность — МЕНЯЕМ только если другое ε

sol = ode45(odefun,[x0,xf],IC,opts);
% ode45 — НЕ ТРОГАЕМ

zq = deval(sol,xq);
y_q = zq(1);
% z(1)=y, извлекаем y(xq)

fprintf('%.4f\n', y_q);
% ответ с четырьмя знаками после запятой


%++++++
% 4) Atrisināt Koši problēmu y' - x^2siny = -y^2x,  
% y(0) = 1 intervālā [0, 2.5].  
% Uzzīmēt funkcijas y(x) grafiku.

%%4uzdevuns
clc; clearvars; close all;
format compact;
% служебные команды — НЕ ТРОГАЕМ

x0 = 0;
xf = 2.5;
% интервал из условия

IC = 1;
% начальное условие y(0)
% МЕНЯЕМ ТОЛЬКО число

odefun = @(x,y) x.^2.*sin(y)-x.*y.^2;
% правая часть дифференциального уравнения
% ЭТУ СТРОКУ МЕНЯЕМ при другом уравнении
% ВСЁ НИЖЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-8,'AbsTol',1e-9);
% точность

sol = ode45(odefun,[x0,xf],IC,opts);
% ode45 — НЕ ТРОГАЕМ

xx = linspace(x0,xf,500);
yy = deval(sol,xx);
% получение решения — НЕ ТРОГАЕМ

figure;
plot(xx,yy,'LineWidth',1.2);
grid on;
% построение графика y(x)


%++++++++
% 5) Atrisināt Košī problēmu  

% dy1/dx = 1/3 * y1 - 0.02y1y2  
% dy2/dx = -y1 + 0.02y1y2  

% y1(1.8) = 1.25, y2(1.8) = 0.88 intervālā (1.8, 8.2).  
% Atrast y2(4.42). Atbildi dod ar četriem cipariem aiz komata.


%%5uzdevums
clc; clearvars; close all;
format long;
% служебные команды — НЕ ТРОГАЕМ

x0 = 1.8;
xf = 8.2;
% интервал решения

xq = 4.42;
% точка, где нужно найти y2

IC = [1.25;0.88];
% IC(1)=y1, IC(2)=y2
% начальные условия — МЕНЯЕМ по условию

odefun = @(x,y)[(1/3)*y(1)-0.02*y(1)*y(2);-y(1)+0.02*y(1)*y(2)];
% система дифференциальных уравнений
% ЭТУ СТРОКУ МЕНЯЕМ при другой системе
% ВСЁ НИЖЕ НЕ ТРОГАЕМ

opts = odeset('RelTol',1e-8,'AbsTol',1e-9);
% точность

sol = ode45(odefun,[x0,xf],IC,opts);
% ode45 — НЕ ТРОГАЕМ

Yq = deval(sol,xq);
y2_q = Yq(2);
% извлекаем y2(xq)

fprintf('%.4f\n',y2_q);
% вывод результата с четырьмя знаками






